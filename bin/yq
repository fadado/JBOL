#!/bin/bash

#
# Wraps jq to be able to process YAML
#

# Script name
declare -r SELF=${0##*/}

# Options
set -o pipefail
set -o errexit
set -o noglob
set -o nounset
shopt -s expand_aliases

# Format conversors
alias y2j=$(dirname $0)/y2j
alias j2y=$(dirname $0)/j2y

function help {
    cat <<\EOF
yq - commandline YAML processor
Usage: yq [options] <jq filter> [file]

    yq is a wrapper to jq for processing YAML input, applying the given
    filter to it YAML text input and producing the filter's results as
    YAML or JSON on standard output.

    The options available are yq specific and also from jq. The yq
    options are:
     -h     Show this help
     -J     Preserve JSON output format
     -V     Output the jq version
    
    Some of the jq options include:
     -e     set the exit status code based on the output
     -f     Read filter from the file f
     -s     read (slurp) all inputs into an array; apply filter to it
     -S     sort keys of objects on output
     --arg a v          set variable $a to value v
     --argjson a v      set variable $a to JSON value v
     --slurpfile a f    set variable $a to an array of values read from f
    Not all jq options have sense using yq.

    For more advanced filters see the jq(1) manpage and
    https://stedolan.github.io/jq
EOF
    exit $(( $# == 0 ))
}

function die {
    echo 1>&2 "${SELF}: $@"
    exit 1
}

function main {
    local -i json=0

    local opt
    while getopts :hJKV-: opt; do
        case $opt in
            h) help ;; 
            J) json=1 ;; 
            V) exec jq --version ;;
            -) case $OPTARG in
                   help) help ;;
                   JSON|json) json=1 ;;
                   *) OPTIND=$((OPTIND-1)) 
                      break ;; # assume jq option
               esac
               ;;
            ?) OPTIND=$((OPTIND-1)) 
               break ;; # assume jq option
        esac
    done

    shift $((OPTIND-1))
    (( $# > 0 )) || help
    [[ $1 == '--version' ]] && exec jq --version

    # is stdin a TTY?
    if [[ -t 0 ]]; then
        if (( $# >= 2 )); then
            # is the last parameter a regular file?
            local last="${!#}"
            if [[ -f $last ]]; then
                exec 0< "$last"
                set -- "${@:1:$(($#-1))}"
            fi
        fi
    fi

    # Wrap jq
    if (( json )); then
        # Preserve JSON output
        y2j | jq "$@"
    else
        y2j | jq "$@" | j2y
    fi
}

#
# Call main
#

main "$@"

exit $?

# vim:ai:sw=4:ts=4:et:syntax=sh
